#!/bin/bash
# =============================================================================
# SteamMachine-DIY - steamos-session-launch
# =============================================================================
# Script:      sdy
# Version:     4.0.0
# Philosophy:  KISS (Keep It Simple, Stupid)
# Description: Minimal environment with ACTIVE recovery watchdog.
# Repository: https://github.com/dlucca1986/SteamMachine-DIY
# Path:        /usr/local/bin/steamos-session-launch
# License: MIT
# =============================================================================

set -uo pipefail

# --- 1. CARICAMENTO GERARCHICO (SSoT) ---
# Carica prima i defaults di sistema, poi il master config, poi l'user config
source "/usr/share/steamos-diy/defaults" 2>/dev/null || { echo "Defaults missing"; exit 1; }
source "/etc/default/steamos-diy" 2>/dev/null || { echo "Master Config missing"; exit 1; }
[[ -f "${CONF_DIR}/config" ]] && source "${CONF_DIR}/config"

# Funzione Log Uniformata (Soluzione A - Inlined)
log() {
    local level=$1
    local msg=$2
    # Scrittura su file (se accessibile) e su Journal
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [SDY] [$level] $msg" >> "${LOG_FILE}" 2>/dev/null || true
    echo "[$level] $msg" | systemd-cat -t "steamos-diy"
}

# --- 2. HARDWARE DETECTION ---
# Agnostico: non diamo per scontata la risoluzione, la cerchiamo
DRM_PATH=$(dirname $(grep -l "^connected" /sys/class/drm/card*-*/status | head -n1) 2>/dev/null || echo "")
NATIVE_RES=$(head -n1 "$DRM_PATH/modes" 2>/dev/null || echo "${DEFAULT_RES}")
HW_W=${NATIVE_RES%x*}
HW_H=${NATIVE_RES#*x}

FINAL_W=${TARGET_WIDTH:-$HW_W}
FINAL_H=${TARGET_HEIGHT:-$HW_H}

# --- 3. GAMESCOPE SETUP ---
G_OPTS=("-e" "-W" "$FINAL_W" "-H" "$FINAL_H")

# Traduttore variabili Master (uniformato al nuovo SSoT)
[[ "${ENABLE_MANGOAPP:-0}" == "1" ]] && G_OPTS+=("--mangoapp")
[[ "${ENABLE_HDR:-0}" == "1" ]]      && G_OPTS+=("--hdr-enabled")
[[ "${ENABLE_VRR:-0}" == "1" ]]      && G_OPTS+=("--adaptive-sync")
[[ "${ENABLE_FSR:-0}" == "1" ]]      && G_OPTS+=("-F" "fsr")
[[ -n "${REFRESH_RATE:-}" ]]        && G_OPTS+=("-r" "$REFRESH_RATE")

# Gestione argomenti extra (Agnostico verso Gamescope)
if [[ -n "${GAMESCOPE_ARGS:-}" ]]; then
    read -r -a EXTRA_ARGS <<< "$GAMESCOPE_ARGS"
    G_OPTS+=("${EXTRA_ARGS[@]}")
fi

# --- 4. WATCHDOG & SIGNALS ---
cleanup_session() {
    log "EXIT" "Shutdown signal received. Cleaning up..."
    if [[ -n "${G_PID:-}" ]]; then
        kill -TERM "$G_PID" 2>/dev/null
        # Ciclo di attesa ultra-lean
        for i in {1..2}; do kill -0 "$G_PID" 2>/dev/null || break; sleep 1; done
    fi
    exit 0
}
trap cleanup_session SIGINT SIGTERM

# --- 5. EXECUTION LOOP ---
MAX_RETRIES=2
RETRY_COUNT=0

while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
    CUR_STEAM="${STEAM_CMD}"
    [[ $RETRY_COUNT -gt 0 ]] && CUR_STEAM="${STEAM_CMD} -autoconfig"

    log "LAUNCH" "Starting Gamescope: ${FINAL_W}x${FINAL_H} (Try: $((RETRY_COUNT + 1)))"
    START=$(date +%s)

    # Nota: Usiamo variabili per i comandi, non percorsi fissi
    gamescope "${G_OPTS[@]}" -- env ${CUR_STEAM} >> "${LOG_FILE}" 2>&1 &
    G_PID=$!
    wait "$G_PID" || true

    # Logica crash: se dura meno di 10 secondi è un fallimento
    if [ $(( $(date +%s) - START )) -lt 10 ]; then
        ((RETRY_COUNT++))
        log "WATCHDOG" "Crash detected. Attempt ${RETRY_COUNT}/${MAX_RETRIES}"
        sleep 2
    else
        # Uscita pulita dell'utente
        log "EXIT" "Session ended normally."
        exit 0
    fi
done

# --- 6. FALLBACK (Enterprise Logic) ---
if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
    log "CRITICAL" "Max retries reached. Failing service to trigger OnFailure."
    # NON chiamiamo session-select. Usciamo con errore.
    # Systemd si occuperà di avviare Plasma tramite OnFailure nel service.
    exit 1
fi
